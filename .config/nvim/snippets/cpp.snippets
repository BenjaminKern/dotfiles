extends c

snippet Inc Preprocessor #include<...>
	#include <${1:iostream}>
snippet Tcls Type Erased Class
	/*! \class ${1:$TM_FILENAME_BASE}
	 *  \brief ${10:Brief class description}
	 *
	 *  ${11:Detailed description}
	 */
	class ${1} {
	public:
	  template <typename T>
	  explicit ${1}(T const &x) : m_pimpl{std::make_unique<Model<T>>(x)} {}
	  ${1}(${1} const &other) : m_pimpl(other.m_pimpl->clone()) {}
	  ${1}(${1} &&) noexcept = default;
	  ${1} &operator=(${1} rhs) {
	    swap(*this, rhs);
	    return *this;
	  }
	  friend void swap(${1} &first, ${1} &second) {
	    using std::swap;
	    swap(first.m_pimpl, second.m_pimpl);
	  }
	  /*! \brief ${6:Brief method description}
	   *
	   *  ${7:Detailed method description}
	   *
	   * \param ${5:x} ${8:Parameter description}
	   * \return ${9:Return parameter description}
	   */
	  ${2:int} ${3:doFoo}(${4:int} ${5}) {
	    return m_pimpl->${3}(${5});
	  }
	private:
	  class Concept {
	  public:
	    virtual ~Concept() = default;
	    virtual ${2} ${3}(${4} ${5}) = 0;
	    virtual std::unique_ptr<Concept> clone() const = 0;
	  };
	  template <typename T> class Model : public Concept {
	  public:
	    explicit Model(T const &model) : m_model{model} {}
	    explicit Model(T &&model) : m_model{std::move(model)} {}

	    std::unique_ptr<Concept> clone() const override {
	      return std::make_unique<Model>(*this);
	    }

	    ${2} ${3}(${4} ${5}) override { return m_model.${3}(${5}); }

	  private:
	    T m_model;
	  };
	  std::unique_ptr<Concept> m_pimpl;
	};
snippet Pcls Pimpl Class
	#include <memory>

	namespace ${1:foo} {
	/*! \class ${2:$TM_FILENAME_BASE}
	 *  \brief ${13:Brief class description}
	 *
	 *  ${14:Detailed description}
	 */
	class ${2} {
	public:
	  explicit ${2}(${3:int} ${4:x});
	  ${2}();
	  ${2}(${2} const&) = delete;
	  ${2}(${2}&&);
	  ${2} &operator=(${2}&) = delete;
	  ${2} &operator=(${2}&&);
	  ~${2}();
	  /*! \brief ${9:Brief method description}
	   *
	   *  ${10:Detailed method description}
	   *
	   * \param ${8:x} ${11:Parameter description}
	   * \return ${12:Return parameter description}
	   */
	  ${5:int} ${6:doFoo}(${7:int} ${8});
	private:
	  class Impl;
	  std::unique_ptr<Impl> m_pimpl;
	};

	} // namespace ${1}

	using namespace ${1};

	class ${2}::Impl {
	  public:
	    explicit Impl(${3:int} ${4:x}) : m_${4}{x} {}
	    ${5} ${6}(${7} ${8}) {
	      ${0}
	      return {};
	    }

	  private:
	    ${3} m_${4}{};
	};

	${2}::${2}(${3} ${4}) : m_pimpl{std::make_unique<Impl>(${4})} {}

	${2}::${2}() = default;
	${2}::${2}(${2}&&) = default;
	${2}::~${2}() = default;
	${2}& ${1}::${2}::operator=(${2}&&) = default;

	${5} ${1}::${2}::${6}(${7} ${8}) {
	    return m_pimpl->${6}(${8});
	}
snippet Cls Class
	#include <utility>
	namespace ${1:foo} {
	/*! \class ${2:$TM_FILENAME_BASE}
	 *  \brief ${13:Brief class description}
	 *
	 *  ${14:Detailed description}
	 */
	class ${2} {
	public:
	  explicit ${2}(${3:int} ${4:x});
	  ${2}() = delete;
	  ${2}(${2} const&) = default;
	  ${2}(${2}&&) = default;
	  ${2} &operator=(${2}&) = default;
	  ${2} &operator=(${2}&&) = default;
	  ~${2}() = default;
	  friend void swap(${2}& first, ${2}& second) {
	    using std::swap;
	    swap(first.m_${4}, second.m_${4});
	  }
	  /*! \brief ${9:Brief method description}
	   *
	   *  ${10:Detailed method description}
	   *
	   * \param ${8:x} ${11:Parameter description}
	   * \return ${12:Return parameter description}
	   */
	  ${5:int} ${6:doFoo}(${7:int} ${8});
	private:
	  ${3} m_${4};
	};

	} // namespace ${1}

	using namespace ${1};

	${2}::${2}(${3} ${4}) : m_${4}{${4}} {}

	${5} ${1}::${2}::${6}(${7} ${8}) {
	    return {};
	}
