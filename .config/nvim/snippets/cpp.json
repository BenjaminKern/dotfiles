{
  "main template": {
    "prefix": "mainn",
    "body": ["int main(int argc, char** argv) {", "  $0", "  return 0;", "}"],
    "description": "main() snippet"
  },
  "google test template": {
    "body": [
      "#include <gtest/gtest.h>",
      "namespace {",
      "class ${1:FooTest}State : public testing::Test {",
      " protected:",
      "  void SetUp() override {",
      "    m_x = 5;",
      "  }",
      "  void TearDown() override {",
      "    m_x = 0;",
      "  }",
      "  void check(int const& x) {",
      "    ASSERT_EQ(x, m_x);",
      "  }",
      "  int m_x{};",
      "};",
      "}",
      "TEST_F(${1}State, ShouldBeOk) {",
      "  int x = 5;",
      "  check(x);",
      "}",
      "TEST(${1}, ShouldBeOk) {",
      "  EXPECT_TRUE(true);",
      "}",
      "${0}"
    ],
    "description": "Google test",
    "prefix": "gtst"
  },
  "google benchmark template": {
    "body": [
      "#include <benchmark/benchmark.h>",
      "namespace {",
      "template<typename T>",
      "static void ${1:fooBench}(T&& data) {",
      "}",
      "template<typename T>",
      "class ${1}State : public benchmark::Fixture {",
      "  public:",
      "    void SetUp(const::benchmark::State& state) {",
      "      m_range = state.range(0);",
      "    }",
      "    void TearDown(const::benchmark::State&) {",
      "      m_range = {};",
      "    }",
      "  T m_data{};",
      "  int64_t m_range{};",
      "};",
      "BENCHMARK_TEMPLATE_DEFINE_F(${1}State, ${1}, ${2:int})(benchmark::State& state) {",
      "  for (auto _ : state) {",
      "    ${1}(m_data);",
      "  }",
      "}",
      "}",
      "BENCHMARK_REGISTER_F(${1}State, ${1})->Name(\"${3:Benchmark for} ${2} ${1}\")->ThreadRange(${4:1}, ${5:4})->DenseRange(0, ${6:512}, ${7:128});",
      "BENCHMARK_MAIN();",
      "${0}"
    ],
    "description": "Google benchmark",
    "prefix": "gbench"
  },
  "pimpl class template": {
    "body": [
      "#include <memory>",
      "namespace ${1:foo} {",
      "/// @class ${2:$TM_FILENAME_BASE}",
      "/// @brief ${13:Brief class description}",
      "///",
      "/// ${14:Detailed description}",
      "///",
      "class ${2} {",
      "public:",
      "  explicit ${2}(${3:int} ${4:x});",
      "  ${2}();",
      "  ${2}(${2} const&) = delete;",
      "  ${2}(${2}&&);",
      "  ${2} &operator=(${2}&) = delete;",
      "  ${2} &operator=(${2}&&);",
      "  ~${2}();",
      "  /// @brief ${9:Brief method description}",
      "  ///",
      "  ///  ${10:Detailed method description}",
      "  ///",
      "  /// @param ${8:x} ${11:Parameter description}",
      "  /// @return ${12:Return parameter description}",
      "  ///",
      "  ${5:int} ${6:doFoo}(${7:int} ${8});",
      "private:",
      "  class Impl;",
      "  std::unique_ptr<Impl> m_pimpl;",
      "};",
      "} // namespace ${1}",
      "${0}",
      "using namespace ${1};",
      "class ${2}::Impl {",
      "  public:",
      "    explicit Impl(${3:int} ${4:x}) : m_${4}{x} {}",
      "    ${5} ${6}(${7} ${8}) {",
      "      return {};",
      "    }",
      "  private:",
      "    ${3} m_${4}{};",
      "};",
      "${2}::${2}(${3} ${4}) : m_pimpl{std::make_unique<Impl>(${4})} {}",
      "${2}::${2}() = default;",
      "${2}::${2}(${2}&&) = default;",
      "${2}::~${2}() = default;",
      "${2}& ${1}::${2}::operator=(${2}&&) = default;",
      "${5} ${1}::${2}::${6}(${7} ${8}) {",
      "    return m_pimpl->${6}(${8});",
      "}"
    ],
    "description": "pimpl class",
    "prefix": "pcls"
  }
}
